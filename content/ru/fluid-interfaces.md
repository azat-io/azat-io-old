---
title: Резиновые интерфейсы
description: Используем CSS-функцию clamp() для создания резиновых интерфейсов
date: 2022-08-18
hero:
  avif: /posts/fluid-interfaces.avif
  webp: /posts/fluid-interfaces.webp
image: /posts/fluid-interfaces-preview.png
---

Охаё, как говорится.

Сегодняшний веб представляет собою дикий зоопарк всевозможных устройств, на которых можно запустить браузер. И, стало быть, наш сайт должен бодро смотреться как на разных мобилках, так и на планшетах, ноутах, настольных компьютерах.

Из-за маленького размера экранов мобильных девайсов, например, имеет смысл изменять те же размеры шрифтов и всевозможных отступов на странице в меньшую сторону.

Благо есть парочка способов средствами CSS задать размер шрифта, который бы весело масштабировался между различными значениями в пределах определённого диапазона ширины вьюпорта.

Как правило, в бытность свою среднестатистический разраб в этих целях юзает медиавыражения. Выглядит это примерно так:

```css
.button {
  padding: 2px 4px;
  font-size: 1.25rem;
  background: blue;
  border: none;
  border-radius: 4px;
}

@media screen and (min-width: 760px) {
  .button {
    padding: 4px 12px;
    font-size: 1.5rem;
    border-radius: 6px;
  }
}
```

Но, думается мне, способ этот уныл, как аграрная промышленность. Прежде всего он вгоняет в тоску из-за того, что приходится писать много кода, можно даже сказать, что ты пишешь в одном файле CSS-код дважды. А ещё было бы забавно учитывать промежуточные значения для всех отступов и размеров, то есть сделать кнопку по-настоящему резиновой.

Итак, для примера, предположим, нам нужно задать шрифт, который будет изменяться в диапазоне между шириной 480 и 1280 пикселей. Минимальный размер шрифта будет `2.25rem`, максимальный - `3rem`.

Какие есть способы сделать это весело?

## Функция calc()

Данная функция применяется для выполнения простых вычислений в CSS, в связке с единицей измерения `vw` (процентная величина от общей ширины области просмотра) эта функция становится мощным инструментом в разработке адаптивного интерфейса. Она и может нам помочь в том, чтобы рассчитать необходимый размер шрифта в нужном нам диапазоне.

Для начала определим разницу между максимальным и минимальным размерами шрифта. В нашем примере это будет: `3rem - 2.25rem = 0.75rem`.

Также определим разницу между значениями вьюпорта, предварительно преобразовав их значение в единицу `rem` (зависит от значения `<html>`, по‑умолчанию `16px`). Получаем вот что: `(1280 / 16) - (480 / 16) = 50`.

Таким образом, мы получили следующие значения:

- Минимальный размер шрифта: `2.25rem`
- Максимальный размер шрифта: `3rem`
- Разница между максимальным и минимальным размерами шрифта: `0.75rem`
- Минимальный размер вьюпорта: `30rem (480px)`
- Разница между максимальным и минимальным размерами вьюпорта: `50rem (800px)`

Необходимая нам функция должна выглядеть следующим образом:

Минимальный размер шрифта + Разница между максимальным и минимальным размерами шрифта \* ((Ширина вьюпорта - Минимальный размер вьюпорта) / Разница между максимальным и минимальным размерами вьюпорта).

Итого получаем следующий результат:

```css
.foo {
  font-size: 2.25rem;
}

@media screen and (min-width: 480px) and (max-width: 1280px) {
  .foo {
    font-size: calc(2.25rem + 0.75 * ((100vw - 30rem) / 50));
  }
}

@media screen and (min-width: 1280px) {
  .foo {
    font-size: 3em;
  }
}
```

Уже веселее, но пока что всё по-прежнему многословно.

## Функция clamp()

Но, пожалуй, наиболее лаконичным и молодёжным способом, можно считать функцию `clamp()`, которая создана для задания значения в диапазоне между указанными нижней и верхней границами. Очевидно, что в нашем случае границами будут являться минимальное и максимальное значение CSS свойства.

Всё, что нам остаётся - это найти предпочитаемое значение размера шрифта. Для этого нам будет необходимо выполнить ряд возможно нетривиальных операций.

![График функции clamp](/posts/fluid-interfaces-01.webp)

Итак, у нас есть координатная плоскость, по оси X расположены величины ширины окна браузера, а по оси Y значения CSS свойств. Нам нужно найти точку, в которой график функции пересекает ось ординат. Как мы помним из занудных уроков геометрии в школе, делается по угловому коэффициенту.

Угловой коэффициент, напомню, это отношение изменения координаты Y (двух точек) к изменению координаты X (двух точек). Изменение координаты – это разность между значениями соответствующей координаты первой и второй точек. Окей, погнали: разницу между максимальным и минимальным размерами шрифта разделим на разницу между максимальным и минимальным размерами вьюпорта (одновременно с этим конвертируем размеры вьюпорта из px в rem для удобства): `(3 - 2.25) / ((1280 / 16) - (480 / 16)) = 0.015`

Итак, мы выяснили, что угловой коэффициент равен `0.015`. Теперь найдём пересечение по оси Y по формуле: минимальный размер вьюпорта, преобразованный в отрицательное число, умноженный на угловой коэффициент плюс минимальный размер шрифта: `(0 - (480 / 16)) * 0.015 + 2.25 = 1.8`

Предпочитаемое значение размера шрифта будет равно пересечению по оси Y + (угловой коэффициент \* 100)vw.

```css
.foo {
  font-size: clamp(2.25rem, 1.8rem + 1.5vw, 3rem);
}
```

## PostCSS плагин

![postcss-responsive >](/posts/fluid-interfaces-02.webp =176x220)

Вся эта математика кажется излишне утомительной, особенно если речь идёт о разработке большого веб-приложения или целой дизайн-системы. Посему на потеху публике я запилил соответствующий плагин [postcss-responsive](https://github.com/azat-io/postcss-responsive).

Для того чтобы начать использовать резиновую типографику у себя в проекте, достаточно просто установить PostCSS плагин:

```sh
pnpm add postcss-responsive
```

Далее добавляем его в наш PostCSS конфиг:

```json
{
  "plugins": {
    "postcss-responsive": {
      "minWidth": 480,
      "maxWidth": 1280
    }
  }
}
```

Вот и всё. Теперь мы можем использовать функцию `responsive()` в наших стилях, в которую достаточно передать два аргумента: минимальный и максимальный размеры шрифта, а предпочитаемое значение уже вычислит PostCSS-плагин:

```postcss
/* Input */

.foo {
  font-size: responsive(2.25rem, 3rem);
}

/* Output */

.foo {
  font-size: clamp(2.25rem, 1.8rem + 1.5vw, 3rem);
}
```

На самом деле данный плагин можно использовать не только при разработке отзывчивой типографики, но также и для всех остальных CSS свойств.

```postcss
.container {
  display: grid;
  grid-template-columns: responsive(180px, 240px) 1fr;
  grid-gap: responsive(8px, 16px);
  padding: responsive(16px, 32px) responsive(16px, 24px);
  font-size: responsive(1rem, 1.125rem);
  line-height: responsive(1.5rem, 1.75rem);
}
```

Таким образом, мы с лёгкостью можем создавать по-настоящему резиновые интерфейсы и избежать использования медиавыражений.
